{\rtf1\ansi\uc1\deff0\deflang1024
{\fonttbl{\f0\fnil\fcharset0 Times New Roman;}
{\f1\fnil\fcharset0 Arial;}
{\f2\fnil\fcharset0 Arial;}
{\f3\fnil\fcharset0 Courier New;}
{\f4\fnil\fcharset0 Zapf Chancery;}
{\f5\fnil\fcharset0 STIXGeneral;}
{\f6\fnil\fcharset0 MS Gothic;}
}
{\colortbl;
\red0\green0\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red0\green255\blue0;
\red255\green0\blue255;
\red255\green0\blue0;
\red255\green255\blue0;
\red255\green255\blue255;
}
{\stylesheet
{\s0\qj\widctlpar\f0\fs24 \snext0 Normal;}
{\cs10 \additive\ssemihidden Default Paragraph Font;}
{\s1\qc\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 Part;}
{\s2\ql\sb240\sa120\keepn\f0\b\fs40 \sbasedon0\snext0 heading 1;}
{\s3\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 2;}
{\s4\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext0 heading 3;}
{\s5\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 4;}
{\s6\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 5;}
{\s7\ql\sb240\sa120\keepn\f0\b\fs24 \sbasedon0\snext0 heading 6;}
{\s8\qr\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext8 rightpar;}
{\s9\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext9 centerpar;}
{\s10\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext10 leftpar;}
{\s11\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equation;}
{\s12\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationNum;}
{\s13\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlign;}
{\s14\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationAlignNum;}
{\s15\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArray;}
{\s16\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 equationArrayNum;}
{\s17\ql\sb120\sa120\keep\widctlpar\f0\fs20 \sbasedon0\snext0 theorem;}
{\s18\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 bitmapCenter;}
{\s20\qc\sb240\sa240\b\f0\fs36 \sbasedon0\snext21 Title;}
{\s21\qc\sa120\f0\fs24 \sbasedon0\snext0 author;}
{\s22\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext22 footer;}
{\s23\ql\tqc\tx4536\tqr\tx9072\f0\fs20 \sbasedon0\snext23 header;}
{\s30\ql\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 caption;}
{\s31\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext0 Figure;}
{\s32\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext32 Table;}
{\s33\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext33 Tabular;}
{\s34\qc\sb120\sa0\keep\widctlpar\f0\fs20 \sbasedon0\snext34 Tabbing;}
{\s35\qj\li1024\ri1024\fi340\widctlpar\f0\fs20 \sbasedon0\snext35 Quote;}
{\s38\ql\widctlpar\f3\fs24 \snext38 verbatim;}
{\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext46 List;}
{\s47\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext47 List 1;}
{\s50\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 latex picture;}
{\s51\qc\sb120\sa120\keep\widctlpar\f0 \sbasedon0\snext0 subfigure;}
{\s61\ql\sb240\sa120\keepn\f0\b\fs32 \sbasedon0\snext62 bibheading;}
{\s62\ql\fi-567\li567\sb0\sa0\f0\fs20 \sbasedon0\snext62 bibitem;}
{\s64\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs20 \sbasedon0\snext64 endnotes;}
{\s65\ql\fi-113\li397\lin397\f0\fs24 \sbasedon0\snext65 footnote text;}
{\s66\qj\fi-170\li454\lin454\f0\fs24 \sbasedon0\snext66 endnote text;}
{\cs62\super \additive\sbasedon10 footnote reference;}
{\cs63\super \additive\sbasedon10 endnote reference;}
{\s67\ql\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext67 acronym;}
{\s70\qc\sa120\b\f0\fs24 \sbasedon0\snext71 abstract title;}
{\s71\qj\li1024\ri1024\fi340\widctlpar\f0\fs24 \sbasedon0\snext0 abstract;}
{\s80\ql\sb240\sa120\keepn\f0\b\fs20 \sbasedon0\snext0 contents_heading;}
{\s81\ql\li425\tqr\tldot\tx8222\sb240\sa60\keepn\f0\fs24\b \sbasedon0\snext82 toc 1;}
{\s82\ql\li512\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext83 toc 2;}
{\s83\ql\li1024\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext84 toc 3;}
{\s84\ql\li1536\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext85 toc 4;}
{\s85\ql\li2048\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext86 toc 5;}
{\s86\ql\li2560\tqr\tldot\tx8222\sb60\sa60\keepn\f0\fs24 \sbasedon0\snext86 toc 6;}
}
{\info
{\title Original file was main.tex}
{\doccomm Created using latex2rtf 2.3.17 r1261 (released March 28, 2018) on Thu Feb 13 20:10:00 2020
}
}
{\footer\pard\plain\f0\fs24\qc\chpgn\par}
\paperw12280\paperh15900\margl2680\margr2700\margt2540\margb1760\pgnstart0\widowctrl\qj\ftnbj\f0\aftnnar
{\pard\plain\s20\qc\sb240\sa240\b\f0\fs36\sl240\slmult1 \fi0 Fortran\par
\pard\plain\s21\qc\sa120\f0\fs24\sl240\slmult1 \fi360 Mehedi hasan\par
\pard\plain\s21\qc\sa120\f0\fs24\sl240\slmult1 \fi360 \chdate \par
\column
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 Preface\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 This is a compilation of lecture notes with some books and my own thoughts. This document is not a holy text. So, if there is a mistake, solve it by your own judgement.   \par
\column
\pard\plain\s80\ql\sb240\sa120\keepn\f0\b\fs24\sl240\slmult1 \fi0  Contents\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \par
{\field{\*\fldinst TOC \\o "1-3" }{\fldrslt }}
\page
\pard\plain\s1\qc\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb60 \fi0 Part I\par Notes\par
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter 1\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Introduction\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 1.1  History\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Fortran (FORmula TRANslation) was the first high-level programming language. It was devised by John Backus in 1953. The first Fortran compiler was produced in 1957. Fortran is highly standardized making is extremely portable (able to run on a wide range of platforms). It has passed through a sequence of international standards those underlined below being the most important. {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 66 - original ANSI standard (accepted 1972) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 77 - ANSI x3.9-1978 - standard programming \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 95 - ISO/IEC 1539-1 1997 (minor revision) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 2003 - ISO/IEC 1539-1 : 2004 (E) object oriented programming interpretability with C \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 2008 - ISO/IEC 1539-1 : 2010 - Co array (parallel programming) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Fortran 2018 - Imminent ! \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Fortran is widely used in high performance computing (HPC). Where its ability to run code in parallel on a large number of process makes is popular for computationability demanding tasks a science and engineering. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 1.2  Source Code and Executable Code\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In all high-level languages (Fortran, C++, Java, Python, \u8230?) programmes are written in source code.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 This is a human readable set of instructions that can be created or modified on any computer with any text editor. File types identifies the programming language. eg. Fortran file has file types .f90 or .f95. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 1.3  Compiler\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The job of compiler is to turn source code into machine readable executable code under windows, executable files have file type .exe.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Producing executable code is actually a two-stage process. {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
compiling converts each individual source file into object code. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
object code linking combines all the object files with additional library routine to create an executable program. \par
}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb300 \fi0 1.4  Fortran Compiler\par
{\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
nagfor \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
IFORT (Intel Fortran Compiler) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
GNU Fortran (gfortran) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 4.\tab
Silverfrost FTN95 \par
}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb300 \fi0 1.5  Creating and Compiling Fortran Code\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 You may create, edit, compile and run a Fortran program either {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
From a command line \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
in an Integrated Development Environment (IDE) \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 You can create Fortran source code with any text editor. eg. Notepad. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 1.6  Some Example Code\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 1.6.1  Hello World\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 [caption= Hello world in Fortran]{hello.f90} \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 1.6.2  Quadratic Equation Solve\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The well-known solutions of the quadratic equation {{\field{\*\fldinst{ EQ {\i A}{\i x}\\s\\up6({\fs20 2})+{\i B}{\i x}+{\i C}=0}}{\fldrslt }}
} are {{\field{\*\fldinst{ EQ {\i x}= \\F(\u8722?{\i B}{\u177*} \\R(,{\i B}\\s\\up6({\fs20 2})\u8722?4{\i A}{\i C}),2{\i A})}}{\fldrslt }}
} The program might look like the following: [caption=Quadratic Solver]{quadratic.f90} \par
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter 2\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Basic Elements of Fortran\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 2.1  Variable Names\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 A name is a symbolic link to a location in memory. A variable is a memory location whose value may be changed during execution. Names must: {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
have between 1 and 63 alphanumeric character (alphabet, digits and underscore). \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
start with a letter. \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 One should not use Fortran keyword or standard intrinsic (in-built) function as a variable name. Tempting names that should be avoided in this respect include: counts, len, product, range, scale, size, sum, tiny. The following are valid variable names: SUST_UNITED, as_easy_as_123. The following are not: Math+Physics (\rquote +\rquote  is not allowed), 999help (starts with a number), Hello! (\rquote !\rquote  would be treated a comment not as a part of the variable name) \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.2  Data Types\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 In Fortran there are 5 intrinsic data types. {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
Integer \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
Real \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
Complex \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 4.\tab
Character \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 5.\tab
Logical \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The first three are numeric types while the other two are non-numeric types. It is also possible to have derived data types and pointers. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2.1  Integer\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Integer constants are whole numbers without a decimal point. e.g. 100, +16, -14, 0, 666. They are stored exactly, but their range is limited; typically {{\field{\*\fldinst{ EQ \u8722?2\\s\\up6({\fs20 {\i n}\u8722?1})}}{\fldrslt }}
} to {{\field{\*\fldinst{ EQ 2\\s\\up6({\fs20 {\i n}\u8722?1})\u8722?1}}{\fldrslt }}
}. Where {{\i n}} is either {16} (for 2-byte integer) or 32 (for 4-byte integer). It is possible to change the default range using the {kind} type parameter. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2.2  Real\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Real constant has a decimal point and maybe entered as either fixed point, eg. 442.2 or floating point, eg. 4.122e+02. Real constants are stored in exponential form in memory, no matter how they are entered. They are accurate only to a finite machine precision (which again, can be changed using the {kind} type parameter). \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2.3  Complex\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Complex constants consist of paired real number corresponding to real and imaginary parts. eg. (2.0, 3.0) corresponds to {2+3{\i i}}. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2.4  Character\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Character constants consists of strings of characters enclosed by a pair of delimiters, which may be either single (\rquote ) or double (") quotes. eg. "This is a string", \rquote Department of Mathematics\rquote . The delimiter themselves are not part of the string. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.2.5  Logical\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Logical constants may be either true or false. \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.3  A program to compute square root of a number\par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \sb60 \fi0 \tab
{\field{\*\fldinst{ EQ {\i x}\\s\\do6({\fs20 {\i n}+1})= \\F(1,2) \\b ({\i x}\\s\\do6({\fs20 {\i n}})+ \\F({\i a},{\i x}\\s\\do6({\fs20 {\i n}}))){\u8594*} \\R(,{\i a})}}{\fldrslt }}
\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Using {if (...) exit} [caption=Newton\rquote s method for finding square root (using if)]{rootNewtonIf.f90} Using {do while} [caption=Newton\rquote s method for finding square root (using do while)]{rootNewtonDoWhile.f90} \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.4  Declaration of Variable\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 2.4.1  Type\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Variables should be declared (that is, have either data types defined and memory set aside for them) before any executable statements. This is achieved by a type declaration statement of form, eg. {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 More than one variable can be declared in each statement, eg. {integer i,j,k} \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.4.2  Initialization\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 If desired variables can be initialized in their type-declaration statement. In this case a double colon (: :) must be used. Thus, the above examples might become {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Variables can also be initialized with a data statement. eg.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {data, num, x, z, answer, letter / 20,50, (0.09,1.0), false, \rquote B\rquote /}\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 The data statement must be placed before any executable statement. \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.4.3  Attributes\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 Various attributes may be specified for variables in their type-declaration statement. One such is {parameter}. A variable declaration with this attribute may not have its value changed within the program unit. It is often used to emphasize key physical or mathematical constants. eg. {real, parameter :: gravity=9.81} \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.4.4  Precision and Kind\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 By default, {real x} will occupy 4 bytes of computer memory and will be inaccurate in the sixth significant figure. The accuracy can be increased by replacing this type statement by {lightgray}{{double precision x}} with the floating-point variable now requiring twice as many bytes of memory. Better portability can be used using {kind} parameters. Avoid {double precision} statement by using {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 followed by the declaration for all floating point variable like : {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 To switch to single precision for all floating-point variable just replace 1.0d0 by 1.0 in the first statement.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Intrinsic functions which allow you to determine the kind parameter for different types are {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.5  Operators and Expression\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 2.5.1  Numeric Operator\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 A numeric expression is a formula combining constants, variables and functions using the numeric intrinsic operators given in the following table: {\par
\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0  \par
{\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \fi0 \par
{\trowd\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrt\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { Operator}\cell}
{\pard\intbl\qc {Meaning}\cell}
{\pard\intbl\qc {Precedence (1=highest)}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { **}\cell}
{\pard\intbl\qc {{{\field{\*\fldinst{ EQ {\i x}\\s\\up6({\fs20 {\i y}})}}{\fldrslt }}
} (Exponential)}\cell}
{\pard\intbl\qc {1}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { *}\cell}
{\pard\intbl\qc {{{\i x}{\i y}} (Multiplication)}\cell}
{\pard\intbl\qc {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { /}\cell}
{\pard\intbl\qc {{{\field{\*\fldinst{ EQ  \\F({\i x},{\i y})}}{\fldrslt }}
} (Division)}\cell}
{\pard\intbl\qc {2}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { +}\cell}
{\pard\intbl\qc {{{\i x}+{\i y}} (Addition) or {(+{\i x})} unary plus}\cell}
{\pard\intbl\qc {3}\cell}
\row}
{\trowd\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx1813\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx5403\clbrdrl\brdrs\clbrdrb\brdrs\clbrdrr\brdrs\cellx6899
{\pard\intbl\qc { -}\cell}
{\pard\intbl\qc {{{\i x}\u8722?{\i y}} (Subtraction) or {(\u8722?{\i x})} unary minus}\cell}
{\pard\intbl\qc {3}\cell}
\row}
} \par
}\pard\plain\s32\qc\sb120\sa0\keep\widctlpar\f0\fs24\sl240\slmult1 \sb240 \fi0 Repeated exponential is the single exception to the left-to-right rule for equal precedence. \par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ {\i a}**{\i b}**{\i c}{\u8594*}{{\i a}\\s\\up6({\fs20 {\i b}})}\\s\\up6({\fs20 {\i c}})}}{\fldrslt }}
\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.5.2  Type Coercion\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 When a binary operator has operands of different type, the weaker type is coerced to the stronger type and the result is of the stronger type. eg. {3/10.0{\u8594*}3.0/10.0} \par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.5.3  Character Operator\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 There is only one character operator, concatenation, //, eg. {"shah"//"jalal"} gives {"shahjalal"} \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.6  Line Discipline\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The usual layout of statement is one pre line. However, there may be more than one statement per line separated by a semi colon; eg, a=1.0;b=1.0; c=100\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 is same as the single line statement {radius = degrees * Pi / 180.0} \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 2.7  Remarks\par
\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 2.7.1  Pi\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The constant {{\u960*}} appears a lot in mathematical programming. eg, whenever converting between degrees and radians.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 If a real variable Pi is declared then its value can be set within the program: Pi=3.14159. But it is good to declare it as a parameter in its type statement. eg, {real, parameter :: Pi=3.14159}. Alternatively, a popular method to obtain an accurate value is to insert the result {\par
\pard\plain\s13\ql\sb120\sa120\keep\widctlpar\f0\tqr\tx3105\tql\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ }}{\fldrslt }}
\tab
{\field{\*\fldinst{ EQ {\plain tan}( \\F({\u960*},4))=1.0}}{\fldrslt }}
\par
\pard\plain\s13\ql\sb120\sa120\keep\widctlpar\f0\tqr\tx3105\tql\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ {\f5\u8658*}}}{\fldrslt }}
\tab
{\field{\*\fldinst{ EQ {\i P}{\i i}=4.0*{\i a}{\i t}{\i a}{\i n}(1.0)}}{\fldrslt }}
\par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb120 \fi0 2.7.2  Exponents\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 If an exponent ("Power") is coded as an integer it will be worked out by repeated multiplication.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 eg, {{\i a}**3} will be worked out as a*a*a\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 {{\charscalex50\~}{\charscalex50\~}{\charscalex50\~}{\i a}**(\u8722?3)} will be worked out as 1/(a*a*a)\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 For non-integer powers (including whole numbers if a decimal point is used) the result will be worked out by {{\field{\*\fldinst{ EQ {\i a}\\s\\up6({\fs20 {\i b}})=({\i e}\\s\\up6({\fs20 {\plain ln}{\i a}}))\\s\\up6({\fs20 {\i b}})}}{\fldrslt }}
}\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 a**3.0 will be worked out something akin to {{\field{\*\fldinst{ EQ {\i e}\\s\\up6({\fs20 3.0{\plain ln}{\i a}})}}{\fldrslt }}
}. However, the logarithms of negative numbers don\rquote t exist. So the following Fortran statement is legitimate: \par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \fi0 \tab
{\i x}=(\u8722?1)**2\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 but the next one isn\rquote t\par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \fi0 \tab
{\i x}=(\u8722?1)**2.0\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 The bottom line is that {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
If the exponent is genuinely a whole number, then don\rquote t use a decimal point or for small powers, simply write it explicitly as a repeated multiple. eg, a*a*a \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Take special care with odd roots of negative numbers. e.g, {{\field{\*\fldinst{ EQ (\u8722?1)\\s\\up6({\fs20 1/3})}}{\fldrslt }}
}; ypu should work out the fractional power of the magnitude, then adjust the sign. eg, write {{\field{\*\fldinst{ EQ (\u8722?8)\\s\\up6({\fs20 1/3})}}{\fldrslt }}
} as {{\field{\*\fldinst{ EQ \u8722?(8)\\s\\up6({\fs20 1/3})}}{\fldrslt }}
} \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 {\i Remember} because of the integer arithmetic the Fortran statement x**(1/3) actually evaluates to x**0(=1.0; presumably not intended). To ensure real arithmetic code as x**(1.0/3.0).\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 A useful intrinsic function for setting sign of an expression as sign(x,y)-> absolute value of x times the sign of y. \par
\page
\pard\plain\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Chapter 3\par
\pard\plain\s2\ql\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb240 \fi0 Loops\par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb480 \fi0 3.1  Types of do loop\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 If a block of code is to be performed repeatedly it is out inside a do loop. The basic structure of which is, {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Indentation helps to clarify the logical structure of the code. It is easy to see which section is being repeated.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 There are two basic types of do loops. {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \li600\fi-300 [label=()] \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
Deterministic do loops: The number of times the section is repeated is stated explicitly. eg, {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 This will perform the repeated section once for each value of the counter i=1,2,\u8230?,10.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 The value of i itself may or may not actually be used in the repeated section. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
Non-deterministic do loops: The number of repetitions is not stated in advance. The enclosed section is repeated until some condition is or is not met. This may be done in two alternative ways. The first requires a logical reason for stopping, whist the second requires a logical reason for continuing looping. {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 or, {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}}\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb340 \fi0 3.2  Deterministic Do Loops\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The general form of the do statement in this case is {\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 \qc [Sorry. Ignored {\plain\f3\\begin\{lstlisting\} ... \\end\{lstlisting\}}]\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Note that {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The loop will execute for each value of the variable from value1 to value2 in steps of value3. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
value3 is the stride, it may be negative or positive; if omitted it is assumed to be 1. \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
The counter variable must be integer type (there could be round off errors if using real variables). \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
value1, value2 and value3 may be constant (eg, 100) or expressions evaluating to integer (eg, 6*(2+j)) \par
}\pard\plain\s4\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb180 \fi0 3.2.1  Sample program\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 [caption= A sample program of Deterministic Do loop]{noTalking.f90} Alternatively, the counter (i in the program bellow) may actually be used in the repeated section. [caption=A sample program of do loop with counter used in repeated section]{do.f90} \par
\pard\plain\s3\ql\sb240\sa120\keepn\f0\b\fs32\sl240\slmult1 \sb240 \fi0 3.3  Non-deterministic Do Loops\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 The {if (...) exit} form continues until some logical expression evaluates as {.true.}. Then it jumps out of the loop and continues with the code after the loop. In this form a {.true.} result tells you when to stop looping.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi360 This can actually be used to exit from any form of loop.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 The {do while(...)} form continues until some logical expression evaluates as {.false.}. Then it stops looping and continues with code after the loop. In this a {.true.} result tells you when to continue looping.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 Non-deterministic do loops are particularly good for {\par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
summing power series (looping stops when the absolute value of a term is less than some given tolerance) \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 \bullet\tab
Single-point iteration (looping stops when the change is less than a given tolerance) \par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \sb60 \fi0 As an example of the latter consider the following code for solving the Colebrook-White equation for the friction factor {{\u955*}} in flow through a pipe \par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ  \\F(1, \\R(,{\u955*}))=\u8722?2.0{\plain log}\\s\\do6({\fs20 10}) \\b ( \\F({\i k}\\s\\do6({\fs20 {\i s}}),3.7{\i D})+ \\F(2.51,{\i R}{\i e} \\R(,{\u955*})))}}{\fldrslt }}
\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 The user inputs values of the relative roughness {{\field{\*\fldinst{ EQ  \\F({\i k}\\s\\do6({\fs20 {\i s}}),{\i D})}}{\fldrslt }}
} and Reynolds number {{\i R}{\i e}}. For simplicity the program actually iterates for {\par
\pard\plain\s13\ql\sb120\sa120\keep\widctlpar\f0\tqr\tx3105\tql\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ {\i x}}}{\fldrslt }}
\tab
{\field{\*\fldinst{ EQ =  \\F(1, \\R(,{\u955*})):}}{\fldrslt }}
\par
\pard\plain\s13\ql\sb120\sa120\keep\widctlpar\f0\tqr\tx3105\tql\tx3450\sl240\slmult1 \fi0 \tab
{\field{\*\fldinst{ EQ {\i x}}}{\fldrslt }}
\tab
{\field{\*\fldinst{ EQ = \u8722?2.0{\plain log}\\s\\do6({\fs20 10}) \\b ( \\F({\i k}\\s\\do6({\fs20 {\i s}}),3.7{\i D})+ \\F(2.51,{\i R}{\i e}){\i x})}}{\fldrslt }}
\par
}\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \fi0 [caption=Sample program of simple-point iteration]{friction.f90} \par
\page
\pard\plain\s1\qc\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \fi0 Part II\par Assignment\par
{\page
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 1.\tab
Write a program that prompts the user for a positive integer N and output to the screen the partial sum \par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \li600\fi0 \tab
{\field{\*\fldinst{ EQ {\i S}\\s\\do6({\fs20 {\i N}})= \\F(1,2\\s\\up6({\fs20 2}))+ \\F(2,3\\s\\up6({\fs20 2}))+ \\F(3,4\\s\\up6({\fs20 2}))+\u8230?+ \\F({\i N},({\i N}+1)\\s\\up6({\fs20 2}))}}{\fldrslt }}
\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 Find the output of your program for N=20 \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 2.\tab
Write a program to evaluate the binomial coefficient \par
\pard\plain\s11\ql\sb120\sa120\keep\widctlpar\f0\tqc\tx3450\sl240\slmult1 \li600\fi0 \tab
{\field{\*\fldinst{ EQ {{\i n}}{{\i r}}= \\F({\i n}!,{\i r}!({\i n}\u8722?{\i r})!)}}{\fldrslt }}
\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 for non-negative integer values of n and r input by the user.\par
\pard\plain\s0\qj\widctlpar\f0\fs24\sl240\slmult1 \li600\fi0 Use your program to evaluate the binomial coefficients {{6}{4},{50}{0},{50}{50},{40}{4},{40}{36}} \par
\pard\plain\s46\ql\fi-283\li283\lin283\sb0\sa120\widctlpar\tql\tx283\f0\fs24\sl240\slmult1 \sb50 \li600\fi-300 3.\tab
Write a program that will for any positive integer N input by the user, output the Fibonacci sequence 1,1,2,3,5,\u8230?up to, but not exceeding N. \par
}\page
\pard\plain\s1\qc\sb240\sa120\keepn\f0\b\fs40\sl240\slmult1 \sb60 \fi0 Part III\par Questions from Past Years\par
}}
